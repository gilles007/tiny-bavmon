.include "ggtiny4.ah"

;##################################################################################################################################
;
;  I M P O R T A N T   N O T E :   A S   P E R   G I G A   D E V I C E S   N A N O   O S   S P E C I F I C A T I O N S
;  AT-Tiny Register r25 is a system wide ZERO register (always set to zero by initialization and by each intterupt (just in case)
;  Additionally! Because the Tiny has limited ROM (and to save space) bios interrupts use registers r24~r25 without saving them
;
;##################################################################################################################################

#ifndef  __SFR_OFFSET
#warning __SFR_OFFSET was not defined, you may not be using the right compiler
#define  __SFR_OFFSET    0
#endif




; Events, configuration constants
;==================================
.equ  EVENT_TIMER_BIT,  	0
.equ  EVENT_TIMER,       (1 << EVENT_TIMER_BIT)

; LED is the Linux Heartbeat (if connected to us to enable watchdog)
.equ  EVENT_LED_ON_BIT,   2
.equ  EVENT_LED_ON,      (1 << EVENT_LED_ON_BIT)
.equ  EVENT_LED_OFF_BIT,  3
.equ  EVENT_LED_OFF,     (1 << EVENT_LED_OFF_BIT)



;************************************************
; Target Hardware Constants for library routines
;************************************************

.equ  PORT_IN,              PINB
.equ  PORT_OUT,             PORTB


; PB0: BOOTSTRAP_WD input is used to enable/disable linux heartbeat watchdot
; when tied to ground, this pin will never see any rising edges and WD will be disabled
; when tied to the linux heartbeat LED, this pin will detect the heartbeat and enable WD reset
; NOTE THAT THE CODE ASSUMES THIS TO BE 0 (as we ror PBIN into the cary to then roll C into the signature)
.equ  LINUX_HBLED_BIT,            0
.equ  LINUX_HBLED,               (1 << LINUX_HBLED_BIT)


; PB1: BOOTSTRAP_ON input used to enable/disable Always ON Appliance mode
; weak pulled up externally to +5V will enable the always on Appliance
; weak pulled down externally will disable the always on Appliance mode
; The theory here is that the BAV335x +3.3V is off by default, when pulled up, this pin will read 1 until the BAV +3.3V goes on, pulling this pin down
; this is how we can detect if the PMIC was disabled by software (pin goes high again, unless externally pulled down to disable the always on mode).
; Basically, if this pin is EVER high, then the appliance mode is enabled (not just a bootstrap option really),
; and we are responsible for turning on the PMIC by generating a pulse in the Power Button Port (here below defined)
.equ  BOOTSTRAP_PWR_BIT,          1
.equ  BOOTSTRAP_PWR,             (1 << BOOTSTRAP_PWR_BIT)


; PB2: output to the mosfet which simulates depressing the PMIC power button (when high)
.equ  OUT_PMICBUTTON_BIT,         2
.equ  OUT_PMICBUTTON,            (1 << OUT_PMICBUTTON_BIT)


; PB3: output to the mosfet which produces the BAV335x system wide reset (when high)
; we use the same bit as the GPIO so we can use the status flags to output GPIO values
.equ  OUT_BAVRESET_BIT,           3
.equ  OUT_BAVRESET,              (1 << OUT_BAVRESET_BIT)



;*******************************************
; Target Hardware Constants for application
;*******************************************

; Typical Linux Heartbeat under light load is:
;      RS                          T                               P       Q   RS                          T                         P
;       _____________               _____________                               _____________               ____________ 
;      |             |             |             |                             |             |             |            |
; _____|             |_____________|             |_____________________________|             |_____________|            |__________________
;      .<-- 125ms -->.<-- 155ms -->.<-- 125ms -->.<---------  775ms  --------->.                             .
;      |<--------  280ms  -------->|<----------------  900ms  ---------------->|
;
; https://en.wikipedia.org/wiki/Cardiac_cycle
; https://en.wikipedia.org/wiki/Electrical_conduction_system_of_the_heart


; Let QRS be the beat (LED on) 
.equ  LINUX_RS_MAX,         28    ; If linux heartbeat LED ON lasts longer than this, we log an extra 1 to mark a pulse too long (invalidate possible signature)

.equ  LINUX_STQ_THRESHOLD,  46    ; If the low state lasts less than treshold, shift one '0', otherwise shift two '0'
.equ  LINUX_RSTQ_TIMEOUT,  250    ; every 2.5s without any toggles,heartbeat ON (too long), we push an additional 0 into the signature (triple 0 would invalidate signature)


.equ  RESET_PULSE_LEN,      25    ; Reset pulse is 250ms
.equ  PMICON_PULSE_LEN,     35    ; PMIC Button On pulse is 350ms
.equ  PMICOFF_PULSE_LEN,   710    ; PMIC Button Off pulse is 7.1secs


;***************************************
; Target Application Specific Constants
;***************************************


; FLAG_WD_ENABLED bit is set once we have observed enough regular heartbeats matching the linux signature
; This in turn enables the Linux heartbeat Watchdog functionality where we Reset the BAV upon heartbeat timeouts.
.equ  FLAG_WD_ENABLED_BIT,        7
.equ  FLAG_WD_ENABLED,           (1 << FLAG_WD_ENABLED_BIT)


; FLAG_PMICON flag indicates that we are in the middle of generating a pulse to the PMIC power button to turn it ON
; in this state, we wait for a pre-determined amount of 10ms counts and then release the power button
.equ  FLAG_INPOWER_PULSE_BIT,     5
.equ  FLAG_INPOWER_PULSE,        (1 << FLAG_INPOWER_PULSE_BIT)


; FLAG_RESETON flag indicates that we are in the middle of generating a reset to the BAV board
; 201506: Since I do not want to forever disable ISP by disabling the RESET pin (to make it a GPIO)
; I decided to use the PMIC to reset the board. We can depress the PMIC button for 10 seconds to force a power off
; and then wait and depress the PMIC button again to turn it back on effectively causing the same as a RESET.
.equ  FLAG_INRESET_PULSE_BIT,     4
.equ  FLAG_INRESET_PULSE,        (1 << FLAG_INRESET_PULSE_BIT)


; FLAG_QRST_TIMEOUT is set when a timeout (> 2 some seconds) happens waiting for a LED toggle
; We keep track of this so that next time a LED toggle happens, we do not try to figure out timings, just log the bit
.equ  FLAG_QRST_TIMEOUT_BIT,     1
.equ  FLAG_QRST_TIMEOUT,        (1 << FLAG_QRST_TIMEOUT_BIT)


; FLAG_LED_ISON is set/reset when we receive the toggle LED interrupt event to help us know if we timed out with the LED On or Off.
; We use this flag to push the last status of the LED into the heatbeat_signature when there is a time out on the heartbeat
; (this is why we use bit 0 so we can easily roll it into the carry with one instruction)
.equ  FLAG_LED_IS_ON_BIT,        0
.equ  FLAG_LED_IS_ON,           (1 << FLAG_LED_ISON_BIT)



; The ONEs represent the LED on, single Zero is the short pulse between 2 ONs, and the TWO Zeroes are the long pulse
; so, a valid signature will look like 10s followed by 100s. something like 1010010100101001010010100 
; To detect if watchdog is enabled, we test after a 1 so we will see either 1010 0101 0010 1001 -or- 1001 0100 1010 0101
.equ  LINUX_VALID_SIGHI, 0xA5
.equ  LINUX_VALID_SIGLO, 0x29
