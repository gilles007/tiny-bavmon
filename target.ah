.include "ggtiny4.ah"

;##################################################################################################################################
;
;  I M P O R T A N T   N O T E :   A S   P E R   G I G A   D E V I C E S   N A N O   O S   S P E C I F I C A T I O N S
;  AT-Tiny Register r25 is a system wide ZERO register (always set to zero by initialization and by each intterupt (just in case)
;  Additionally! Because the Tiny has limited ROM (and to save space) bios interrupts use registers r24~r25 without saving them
;
;##################################################################################################################################

#ifndef  __SFR_OFFSET
#warning __SFR_OFFSET was not defined, you may not be using the right compiler
#define  __SFR_OFFSET    0
#endif




; Events, configuration constants
;==================================
.equ  EVENT_TIMER_BIT,  	4
.equ  EVENT_TIMER,       (1 << EVENT_TIMER_BIT)

.equ  EVENT_LINUXHB_BIT,  1
.equ  EVENT_LINUXHB,     (1 << EVENT_LINUXHB_BIT)


;************************************************
; Target Hardware Constants for library routines
;************************************************

.equ  PORT_IN,              PINB
.equ  PORT_OUT,             PORTB


; PB0: BOOTSTRAP_WD input is used to enable/disable linux heartbeat watchdot
; when tied to ground, this pin will never see any rising edges and WD will be disabled
; when tied to the linux heartbeat LED, this pin will detect the heartbeat and enable WD reset
; NOTE THAT THE CODE ASSUMES THIS TO BE 0 (as we ror PBIN into the cary to then roll C into the signature)
.equ  BOOTSTRAP_WD_BIT,           0
.equ  BOOTSTRAP_WD,              (1 << BOOTSTRAP_WD_BIT)



; PB1: BOOTSTRAP_ON input used to enable/disable Always ON Appliance mode
; weak pulled up externally to +5V will enable the always on Appliance
; weak pulled down externally will disable the always on Appliance mode
; The theory here is that the BAV335x +3.3V is off by default, when pulled up, this pin will read 1 until the BAV +3.3V goes on, pulling this pin down
; this is how we can detect if the PMIC was disabled by software (pin goes high again, unless externally pulled down to disable the always on mode).
; Basically, if this pin is EVER high, then the appliance mode is enabled (not just a bootstrap option really),
; and we are responsible for turning on the PMIC by generating a pulse in the Power Button Port (here below defined)
.equ  BOOTSTRAP_PWR_BIT,          1
.equ  BOOTSTRAP_PWR,             (1 << BOOTSTRAP_PWR_BIT)



; PB2: output to the mosfet which simulates depressing the PMIC power button (when high)
.equ  OUT_PMICBUTTON_BIT,         2
.equ  OUT_PMICBUTTON,            (1 << OUT_PMICBUTTON_BIT)

; FLAG_PMICON flag indicates that we are in the middle of generating a pulse to the PMIC power button
; in this stat, we wait for a pre-determined amount of 10ms counts and then release the power button
; NOTE THAT BY USING THE SAME PORT BITS FOR THE FLAGS THAN THE PORT, WE CAN USE THE FLAGS AS A CHACHE VALUE OF THE PORT VALUES
; (thought this would take one more RAM byte than if reading the port pins, I do prefer to do it this way)
.equ  FLAG_INPOWER_PULSE_BIT,     OUT_PMICBUTTON_BIT
.equ  FLAG_INPOWER_PULSE,        (1 << FLAG_INPOWER_PULSE_BIT)



; PB3: output to the mosfet which produces the BAV335x system wide reset (when high)
; we use the same bit as the GPIO so we can use the status flags to output GPIO values
.equ  OUT_BAVRESET_BIT,           3
.equ  OUT_BAVRESET,              (1 << OUT_BAVRESET_BIT)

; FLAG_RESETON flag indicates that we are in the middle of generating a reset to the BAV board
; in this state, we just wait a pre-determined amount of 10ms counts and then release the reset
.equ  FLAG_INRESET_PULSE_BIT,     OUT_BAVRESET_BIT
.equ  FLAG_INRESET_PULSE,        (1 << FLAG_INRESET_PULSE_BIT)




;*******************************************
; Target Hardware Constants for application
;*******************************************

; Let QRS be the beat (LED on) 
.equ  LINUX_QRS_MIN,         5    ; Let this be the shortest accepted on time for the heartbeat LED
.equ  LINUX_QRS_MAX,         8    ; If linux heartbeat LED ON lasts longer than this, we log the 1 a second time to mark a pulse too long (invalidate possible signature)

.equ  LINUX_QSQ_SHORT,      25    ; When heartbeat is OFF for this long, we consider this a short off beat (single 0 in signature)
.equ  LINUX_QSQ_LONG,       40    ; When heartbeat is OFF for this long, we consider this a long off beat (double 0 in signature) 
.equ  LINUX_QRS_TIMEOUT,   250    ; every 2.5s without heartbeat ON (too long), we push an additional 0 into the signature (triple 0 would invalidate signature)


.equ  RESET_PULSE_LEN,      25    ; Reset pulse is 250ms
.equ  PMICON_PULSE_LEN,     35    ; PMIC Button On pulse is 350ms
.equ  PMICOFF_PULSE_LEN,   710    ; PMIC Button Off pulse is 7.1secs


;***************************************
; Target Application Specific Constants
;***************************************


; FLAG_WD_ENABLED bit is set once we have observed enough regular heartbeats matching the linux signature
; This in turn enables the Linux heartbeat Watchdog functionality where we Reset the BAV upon heartbeat timeouts.
.equ  FLAG_WD_ENABLED_BIT,    4
.equ  FLAG_WD_ENABLED,       (1 << FLAG_WD_ENABLED_BIT)


; FLAG_WAIT_LEDOFF flag means we have seen the rising edge of the heartbeat LED and are waiting for the falling edge
; (the rising edge generates an interrupt whereas the falling edge is polled in the 10ms timer)
; (we could also do like I did in the Birdland infrared received and change the edge of the interrupt but this does not require that kind of precision) 
.equ  FLAG_WAIT_LEDOFF_BIT,   5
.equ  FLAG_WAIT_LEDOFF,      (1 << FLAG_WAIT_LEDOFF_BIT)


; The ONEs represent the LED on, single Zero is the short pulse between 2 ONs, and the TWO Zeroes are the long pulse
; so, a valid signature will look like 10s followed by 100s. something like 1010010100101001010010100 
; To detect if watchdog is enabled, we test after a 1 so we will see either 1010 0101 0010 1001 -or- 1001 0100 1010 0101
.equ  LINUX_VALID_SIGHI, 0xA5
.equ  LINUX_VALID_SIGLO, 0x29
